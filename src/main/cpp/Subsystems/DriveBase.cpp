// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/DriveBase.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "Commands/DriveWithJoy.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "ctre/Phoenix.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

DriveBase::DriveBase() : frc::Subsystem("DriveBase") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    sparkyLeftLead.reset(new WPI_TalonSRX(5));
    sparkyRightLead.reset(new WPI_TalonSRX(2));
    differentialDrive1.reset(new frc::DifferentialDrive(*sparkyLeftLead, *sparkyRightLead));
    sparkyLeftFollow.reset(new WPI_TalonSRX(1));
    sparkyRightFollow.reset(new WPI_TalonSRX(3));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS




//Note the Right Side encoder and velocity return negative numbers when moving forward
//the Left Side encoder and velocity return positive numbers when moving forward
// cANSparkMAXJacksFront->SetRampRate(0.0);
// cANSparkMAXJacksFront->SetRampRate(0.0);
}

void DriveBase::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new DriveWithJoy());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


sparkyLeftFollow->Follow(*sparkyLeftLead);
sparkyRightFollow->Follow(*sparkyRightLead);
//sparkyLeftLead->SetInverted(true);
//sparkyRightLead->SetInverted(true);



/*
    const int kTimeoutMs = 30;
    pigeonIMU1->SetFusedHeading(0.0, kTimeoutMs); // reset heading, angle measurement wraps at plus/minus 23,040 degrees (64 rotations) 
    _goStraight = GoStraightOff;
*/
}

void DriveBase::Periodic() {
    // Put code here to be run every loop

}

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.
void DriveBase::JoyDrive(){
    double forBack = DB(Robot::oi->getJoystick1()->GetRawAxis(1));
    double turn = DB(Robot::oi->getJoystick1()->GetRawAxis(4));
	forBack*=-1;


/*
		PigeonIMU::GeneralStatus genStatus;
		double xyz_dps[3];
		pigeonIMU1->GetGeneralStatus(genStatus);
		pigeonIMU1->GetRawGyro(xyz_dps);
        PigeonIMU::FusionStatus *stat = new PigeonIMU::FusionStatus();
		pigeonIMU1->GetFusedHeading(*stat);
		double currentAngle = stat->heading;
		bool angleIsGood = (pigeonIMU1->GetState() == PigeonIMU::Ready) ? true : false;
		double currentAngularRate = xyz_dps[2];
        bool userWantsGoStraight = Robot::oi->getJoystick1()->GetRawButton(5); // top left shoulder button 

		// deadbands so centering joysticks always results in zero output 
		forBack = DB(forBack);
		turn = DB(turn);
		switch (_goStraight) {

			// go straight is off, better check gamepad to see if we should enable the feature 
			case GoStraightOff:
				if (userWantsGoStraight == false) {
					// nothing to do 
				} else if (angleIsGood == false) {
					// user wants to servo but Pigeon isn't connected? 
					_goStraight = GoStraightSameThrottle; // just apply same throttle to both sides 
				} else {
					// user wants to servo, save the current heading so we know where to servo to. 
					_goStraight = GoStraightWithPidgeon;
					_targetAngle = currentAngle;
				}
				break;
	
			// we are servo-ing heading with Pigeon 
			case GoStraightWithPidgeon:
				if (userWantsGoStraight == false) {
					_goStraight = GoStraightOff; // user let go, turn off the feature 
				} else if (angleIsGood == false) {
					_goStraight = GoStraightSameThrottle; // we were servoing with pidgy, but we lost connection?  Check wiring and deviceID setup 
				} else {
					// user still wants to drive straight, keep doing it 
				}
				break;
	
			// we are simply applying the same throttle to both sides, apparently Pigeon is not connected 
			case GoStraightSameThrottle:
				if (userWantsGoStraight == false) {
					_goStraight = GoStraightOff; // user let go, turn off the feature 
				} else {
					// user still wants to drive straight, keep doing it 
				}
				break;
		}
// if we can servo with IMU, do the math here 
		if (_goStraight == GoStraightWithPidgeon) {
			// very simple Proportional and Derivative (PD) loop with a cap,
			 // replace with favorite close loop strategy or leverage future Talon <=> Pigeon features. 
			turn = (_targetAngle - currentAngle) * kPgain - (currentAngularRate) * kDgain;
			// the max correction is the forward throttle times a scalar,
			 // This can be done a number of ways but basically only apply small turning correction when we are moving slow
			 // and larger correction the faster we move.  Otherwise you may need stiffer pgain at higher velocities. 
			double maxThrot = MaxCorrection(forBack, kMaxCorrectionRatio);
			turn = Cap(turn, maxThrot);
		} else if (_goStraight == GoStraightSameThrottle) {
			// clear the turn throttle, just apply same throttle to both sides 
			turn = 0;
		} else {
			// do nothing 
		}
*/
    differentialDrive1->ArcadeDrive(forBack,turn);
}


/** @return 10% deadband */
double DriveBase::DB(double axisVal) {
    if (axisVal < -0.10)
        return axisVal;
    if (axisVal > +0.10)
        return axisVal;
    return 0;
}

double DriveBase::Cap(double value, double peak) {
    if (value < -peak)
        return -peak;
    if (value > +peak)
        return +peak;
    return value;
}

double DriveBase::MaxCorrection(double forwardThrot, double scalor) {
    /* make it positive */
    if (forwardThrot < 0) {
        forwardThrot = -forwardThrot;
    }
    /* max correction is the current forward throttle scaled down */
    forwardThrot *= scalor;
    /* ensure caller is allowed at least 10% throttle,
        * regardless of forward throttle */
    if (forwardThrot < 0.10)
        return 0.10;
    return forwardThrot;
}
